import isPlainObject from './isPlainObject';
const isType = {
    number: (candidate) => typeof candidate === 'number' && !isNaN(candidate),
    string: (candidate) => typeof candidate === 'string',
    integerString: (candidate) => is.notEmptyString(candidate) && is.number(Number(candidate)) && /^-?\d+$/.test(candidate),
    numberString: (candidate) => is.notEmptyString(candidate) &&
        is.number(Number(candidate)) &&
        /^-?\d+(\.\d+)?$/.test(candidate),
    null: (candidate) => candidate === null,
    undefined: (candidate) => candidate === undefined,
    nullOrUndefined: (candidate) => candidate === undefined || candidate === null,
    falsy: (candidate) => !candidate,
    truthy: (candidate) => !!candidate,
    function: (candidate) => typeof candidate === 'function',
    object: (candidate) => typeof candidate === 'object' && candidate !== null,
    plainObject: (candidate) => isPlainObject(candidate),
    array: (candidate) => Array.isArray(candidate),
    boolean: (candidate) => typeof candidate === 'boolean',
    promise: (p) => {
        if (p !== null &&
            typeof p === 'object' &&
            typeof p.then === 'function' &&
            typeof p.catch === 'function') {
            return true;
        }
        return false;
    },
};
const isCheck = {
    notEmptyString: (candidate) => isType.string(candidate) && candidate.length > 0,
    emptyString: (candidate) => isType.string(candidate) && candidate.length === 0,
    emptyArray: (candidate) => isType.array(candidate) && candidate.length === 0,
    notEmptyArray: (candidate) => isType.array(candidate) && candidate.length > 0,
};
const is = Object.assign(Object.assign({}, isType), isCheck);
export default is;
//# sourceMappingURL=is.js.map