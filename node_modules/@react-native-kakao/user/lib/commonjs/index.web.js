"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unlink = exports.shippingAddresses = exports.setAccessTokenWeb = exports.serviceTerms = exports.scopes = exports.revokeScopes = exports.me = exports.logout = exports.login = exports.issueAccessTokenWithCodeWeb = exports.isLogined = exports.isKakaoTalkLoginAvailable = exports.getAccessToken = void 0;
var _jsUtil = require("@mj-studio/js-util");
var _core = require("@react-native-kakao/core");
var querystring = _interopRequireWildcard(require("querystring"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function isoToUnix(value) {
  if (!_jsUtil.is.string(value)) {
    return value;
  }
  return Date.parse(value) / 1000;
}
const KakaoUser = {
  getAccessToken: () => (0, _core.kRunWebAPI)(async () => {
    const {
      id,
      expires_in,
      app_id
    } = (await (0, _core.kFetch)('https://kapi.kakao.com/v1/user/access_token_info', {
      headers: {
        ..._core.kGlobalStorage.headers
      }
    })).body;
    return {
      id,
      expiresIn: expires_in,
      appId: app_id
    };
  }),
  issueAccessTokenWithCodeWeb: ({
    clientSecret,
    code,
    redirectUri
  }) => (0, _core.kRunWebAPI)(async () => {
    const res = await (0, _core.kFetchFormUrlEncoded)('https://kauth.kakao.com/oauth/token', {
      method: 'POST',
      body: (0, _jsUtil.filterNonNullishKeys)({
        grant_type: 'authorization_code',
        client_id: _core.kGlobalStorage.restApiKey,
        redirect_uri: encodeURIComponent(redirectUri),
        code,
        client_secret: clientSecret
      })
    }).then(r => r.body);
    return (0, _jsUtil.camelCaseObject)(res);
  }),
  setAccessTokenWeb: token => {
    _core.kGlobalStorage.accessToken = token;
    return new Promise(r => {
      Kakao.Auth.setAccessToken(token);
      r(42);
    });
  },
  login: params => (0, _core.kRunWebAPI)(() => {
    const {
      loginHint,
      nonce,
      prompt,
      redirectUri,
      scope,
      state,
      throughTalk,
      serviceTerms
    } = (params === null || params === void 0 ? void 0 : params.web) ?? {};
    return Kakao.Auth.authorize((0, _jsUtil.filterNonNullishKeys)({
      loginHint,
      nonce,
      prompt: prompt === null || prompt === void 0 ? void 0 : prompt.join(','),
      redirectUri,
      scope: scope === null || scope === void 0 ? void 0 : scope.join(','),
      serviceTerms: serviceTerms === null || serviceTerms === void 0 ? void 0 : serviceTerms.join(','),
      state,
      throughTalk
    }));
  }),
  logout: () => (0, _core.kRunWebAPI)(() => Kakao.Auth.logout()),
  isLogined: async () => {
    try {
      const {
        appId
      } = await KakaoUser.getAccessToken();
      return !!appId;
    } catch (e) {
      return false;
    }
  },
  isKakaoTalkLoginAvailable: async () => false,
  unlink: () => (0, _core.kRunWebAPI)(() => Kakao.API.request({
    url: '/v1/user/unlink'
  })),
  scopes: scopes => (0, _core.kRunWebAPI)(async () => {
    const response = await Kakao.API.request({
      url: `/v2/user/scopes${scopes ? '?' + querystring.stringify({
        scopes
      }) : ''}`
    });
    return (0, _jsUtil.camelCaseObject)(response.scopes);
  }),
  revokeScopes: scopes => (0, _core.kRunWebAPI)(() => Kakao.API.request({
    url: '/v2/user/revoke/scopes',
    data: {
      scopes
    }
  })),
  serviceTerms: () => (0, _core.kRunWebAPI)(async () => (0, _jsUtil.camelCaseObject)((await Kakao.API.request({
    url: '/v2/user/service_terms'
  })).service_terms.map(v => ({
    ...v,
    agreed_at: v.agreed_at ? isoToUnix(v.agreed_at) : null
  })))),
  shippingAddresses: () => (0, _core.kRunWebAPI)(async () => (0, _jsUtil.camelCaseObject)(await Kakao.API.request({
    url: '/v1/user/shipping_address'
  }))),
  me: () => (0, _core.kRunWebAPI)(async () => {
    const ret = (0, _jsUtil.camelCaseObject)(await Kakao.API.request({
      url: '/v2/user/me'
    }));
    return {
      ...ret,
      connectedAt: isoToUnix(ret.connectedAt),
      synchedAt: isoToUnix(ret.synchedAt)
    };
  })
};
const {
  isKakaoTalkLoginAvailable,
  isLogined,
  login,
  logout,
  me,
  revokeScopes,
  scopes,
  serviceTerms,
  shippingAddresses,
  unlink,
  setAccessTokenWeb,
  issueAccessTokenWithCodeWeb,
  getAccessToken
} = KakaoUser;
exports.getAccessToken = getAccessToken;
exports.issueAccessTokenWithCodeWeb = issueAccessTokenWithCodeWeb;
exports.setAccessTokenWeb = setAccessTokenWeb;
exports.unlink = unlink;
exports.shippingAddresses = shippingAddresses;
exports.serviceTerms = serviceTerms;
exports.scopes = scopes;
exports.revokeScopes = revokeScopes;
exports.me = me;
exports.logout = logout;
exports.login = login;
exports.isLogined = isLogined;
exports.isKakaoTalkLoginAvailable = isKakaoTalkLoginAvailable;
//# sourceMappingURL=index.web.js.map